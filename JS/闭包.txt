闭包，有权访问另一个函数作用域中变量的函数

闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量

闭包的另一个用途是保留了这个变量对象的引用，所以这个变量对象不会被回收


函数执行时会形成一个私有作用域，通常情况下当函数执行完成，栈内存会自动释放（垃圾回收）

但是如果函数执行完成，当前私有作用域(栈内存)中的某一部分内容被内存以外的其它东西(变量/元素的事件)占用了，那么当前的栈内存就不会释放掉，也就形成了不销毁的私有作用域(里面的私有变量也不会销毁)

解决for的问题
for (var i = 0; i < 10; i++) {
    (function(i) {
        setTimeout(() => {
            console.log(i);
        }, 0);
    })(i)
}   

function f1(){
    var n=999;
　　function f2(){  //f2函数就是闭包
　　　　alert(n);
　　}
　　return f2;// 重点在这里，将闭包函数作为返回值，做到f1能访问到f2的内部局部变量
}
var result=f1();
result(); // 999
此时f2函数形成了一个闭包，因f2函数里需要访问f1作用域下的n变量，但他们不处于同一个作用域，故两者相互牵引，需要输出n，f1中的变量n就必须存在，作用域链在f1中找到n，输出n时，垃圾回收机制会认为f2还没有执行完成，但此时作用域链查找已经到了f1作用域下，所以n的内存空间不会被垃圾回收机制清除